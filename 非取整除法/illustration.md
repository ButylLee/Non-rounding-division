# Non-rounding-division illustration

**非取整除法**说明文档

众所周知，除法在C/C++中是会向0取整的，这是一个简单的输出给定精度结果的实现，并且带有四舍五入、去除末尾零的功能。

---

## 原理简介

其实原理很简单，就是小学教的手算除法用的长除法（列竖式）,算出商和余数，然后把余数乘10继续算出下一位的商，以此类推。每次计算只需储存当前位的整数，只需用到整型变量。

## 源码说明

以下按行说明

- `LINE 3` 

  宏定义 `IS_END_ZERO` ，控制除得尽时是否在末尾保留0，其引用在第32行。若不想保留末尾0把宏改为0即可。

- `LINE 7` 

  `dividend` = `被除数` 

  `divisor` = `除数` 

  `quotient` = `商` 

  `remainder` = `余数`

- `LINE 11` 

  条件中0xF左移30位后进行按位或意味着控制精度不超过2^30，换算成十进制约为10亿位。~~然而并没有什么用，因为两数相除肯定是个无限循环小数XD~~

- `LINE 16` 

  在堆内存中创建变长数组 `decimal` 并初始化，这里数组长度比精度 `precision` 多一位是用于四舍五入用，注意这个细节，后面有地方与它相关。使用char是为了节省空间~~虽然没必要~~，计算过程中数组的元素总为正数所以这里用 `signed char` 或 `unsigned char` 都可以，**MSVC**中 `char` 的实现为 `signed char` 。

- `LINE 22-23` 

  计算出整数的商和余数。

- `LINE 24-25` 

  首先，C/C++中除号 `/` 结果的正负由被除数和除数决定，而取余 `%` 结果的正负只由**前面的数**决定。

  而计算结果的正负号由整数部分储存就行了，小数部分 `decimal` 储存的都为正数以便后面输出。

  所以当被除数和除数皆为负时， `LINE 29` 得出的小数部分为正数，不用处理；当被除数和除数一正一负时， `LINE 29` 会得出负数，所以得出整数部分后将除数 `divisor` 取相反数。

  而在循环计算过程中余数 `remainder` 只有乘法和取余运算，其符号不会改变。（意味着换成 `remainder` 取相反数也是可以的）

- `LINE 26` 

  注意此处循环的次数是 `precision + 1` 次。

- `LINE 28-30` 

  这里就是原理部分的实现了。

- `LINE 32-36` 

  这里为了让后面输出部分的代码易读，选择了当能除尽且不保留末尾0时改变 `precision` 为最后一个非0数的下标的方法。

  