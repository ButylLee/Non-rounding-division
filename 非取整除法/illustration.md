# Non-rounding-division illustration

**非取整除法**说明文档

众所周知，除法在C/C++中是会向0取整的，这是一个简单的输出给定精度结果的实现，并且带有四舍五入、去除末尾零的功能。

---

## 原理简介

其实原理很简单，就是小学教的手算除法用的长除法（列竖式）,算出商和余数，然后把余数乘10继续算出下一位的商，以此类推。每次计算只需储存当前位的整数，只需用到整型变量。

## 源码说明

以下按行说明

- `LINE 3` 

  宏定义 `IS_END_ZERO` ，控制除得尽时是否在末尾保留0，其引用在第32行。若不想保留末尾0把宏改为0即可。

  **注意**：若选择不保留末尾0，则当可在整数位整除时（如 `20/4` ），只有在精度为0时才输出一整数（ `=5` ），否则将会保留一个0（ `=5.0` ），~~换而言之这是我有意留的feature~~。

- `LINE 7` 

  `dividend` = `被除数` 

  `divisor` = `除数` 

  `quotient` = `商` 

  `remainder` = `余数`

- `LINE 11` 

  条件中0xF左移30位后进行按位或意味着控制精度不超过2^30，换算成十进制约为10亿位。~~然而并没有什么用，因为两数相除肯定是个无限循环小数XD~~

- `LINE 15` 

  在堆内存中创建变长数组 `decimal` 并初始化为0，这里数组长度比精度 `precision` 多一位是用于四舍五入用，注意这个细节，后面有地方与它相关。使用char是为了节省空间~~虽然没必要~~，计算过程中数组的元素总为正数所以这里用 `signed char` 或 `unsigned char` 都可以，**MSVC**中 `char` 的实现为 `signed char` 。

- `LINE 21-22` 

  计算出整数的商和余数。

- `LINE 23-24` 

  首先，C/C++中除号 `/` 结果的正负由被除数和除数决定，而取余 `%` 结果的正负只由**前面的数**决定。

  而计算结果的正负号由整数部分储存就行了，小数部分 `decimal` 储存的都为正数以便后面输出。

  所以当被除数和除数皆为负时， `LINE 29` 得出的小数部分为正数，不用处理；当被除数和除数一正一负时， `LINE 29` 会得出负数，所以得出整数部分后将除数 `divisor` 取相反数。

  而在循环计算过程中余数 `remainder` 只有乘法和取余运算，其符号不会改变。（意味着换成 `remainder` 取相反数也是可以的）

- `LINE 25` 

  注意此处循环的次数是 `precision + 1` 次。

- `LINE 27-29` 

  这里就是原理部分的实现了。

- `LINE 31-35` 

  这里为了让后面输出部分的代码易读，选择了当能除尽且不保留末尾0时改变 `precision` 为最后一个非0数的下标的方法。

  当除尽时，变量i的值为i，当前计算到第 `i+1` 位小数，即输出精度只需为 `i+1` ： `LINE 34` ，然后 `LINE 35` 用 `break;` 跳出循环。

  然而如果刚好在 `precision + 1` 用于四舍五入而多计算的那一位上除尽了的话， `LINE 34` 就会使结果多输出一位，此时 `i = precision` ，所以在 `LINE 33` 添加条件，排除掉上述情况。

- `LINE 39-49` 

  当条件满足时进行四舍五入，很明显存在连续进位的可能，所以必须有相应处理。

  